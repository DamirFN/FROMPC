# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.

# list_tuples = [[i * b for i in range(1, 11)] for b in range(1, 11)]
# list(map(list, list_tuples))
# for i in range(len(list_tuples)):
#     print(f'{" ".join(str(i) for i in list_tuples[i])}')
#
# for b in range(1, 11):
#     for i in range(1, 11):
#         print(i, '*', b, '=', i * b)
#--------
#  Здесь же можно использовать сразу преобразование в необходимый тип, если он заранее известен.
# L = [set(input()) for i in range(5)]
# print(L)
#--------
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True, если элемент чётный, и False, если
# элемент нечётный.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(L)

# А вот здесь нам и поможет использование функций all([ ]) и any([ ]). Замените знаки «?» таким образом, чтобы
# программа выводила True, если есть хотя бы одно чётное число.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(any(L))

# Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком чётности, если его
# результат будет истинным тогда и только тогда, когда в списке есть хотя бы один чётный и хотя бы один нечётный
# элемент.
# L = [int(input()) % 2 == 0 for i in range(3)]
# print(any(L) and not all(L))
#--------
#  В Python существует функция zip(), позволяющая объединить два списка в новый список кортежей, каждый из которых
#  будет содержать по одному элементу из каждого списка.
# Имеем два списка:
L = [i for i in range(10)]
M = [i for i in range(10, 0, -1)]
# # print(L)
# # print(M)
# # Объединяем два списка:
# for a in zip(L, M):
#     print(a)
# # Преобразуем в более приятный вид,
# for a, b in zip(L, M):
#     print('a =', a, 'b =', b)   #Сначала мы склеили два списка поэлементно, а потом на каждой итерации делали развёртку
# # кортежей на две переменные — a и b, которые использовали в теле самого цикла.

# Найдем произведение каждой пары элементов из двух списков
# for a, b in zip(L, M):
#     print(a * b)
# Или внутри генераторов списков
# N = [a * b for a, b in zip(L, M)]
# print(N)    # Имеет строковый вид
# N = list(N)
# for i in N:
#      print(i)


# acount = 0
# bcount = 0
# ccount = 0
# dcount = 0
# t = "aaabbccccdaa"
# t = list(t)
# print(t)
# for i in t:
#     if i[0] == 'a':
#         acount += 1
#     elif i[0] == 'b':
#         bcount += 1
#     elif i[0] == 'c':
#         ccount += 1
#     elif i[0] == 'd':
#         dcount += 1
# print('a', acount, 'b', bcount, 'c', ccount, 'd', dcount, sep='')

# Реализуйте программу, которая сжимает последовательность символов. На вход подаётся последовательность вида:
# aaabbccccdaa
# Необходимо вывести строку, где каждая последовательность из одинаковых символов, идущих подряд, заменяется на один
# символ, и длину этой последовательности (включая последовательности единичной длины). Вывод должен выглядеть так:
# a3b2c4d1a2
# text = input()  # получаем строку
#
# last = text[0]  # сохраняем первый символ
# count = 0  # заводим счётчик
# result = ''  # и результирующую строку
#
# for c in text:
#     if c == last:  # если символ совпадает с сохранённым,
#         count += 1  # то увеличиваем счётчик
#     else:
#         result += last + str(count)  # иначе записываем в результат
#         last = c  # и обновляем сохранённый символ с его счётчиком
#         count = 1
#
# result += last + str(count)  # и добавляем в результат последний символ
# print(result)
